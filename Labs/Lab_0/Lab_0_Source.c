/*
* Created by Dr. Lazypants
* Completed by Zach Thompson
* 09/08/20
* This program is designed to load data files and then calculate the minimum and maximum values in specific columns
* In this case the data will be blood oxygen consumption levels and ECG voltages
*/


#include <stdlib.h>
#include <string.h> 
#include <stdio.h>

double** load_data(FILE* file, int numrows, int numcols);
int num_rows_in_file(FILE* file);
int num_cols_in_file(FILE* file);

/*
* This function calculates the maximum value in a desired column
*
* @param data_array: A 2D array with rows and columns to examine
* @param column_of_interest: The specific column you want to find the maximum value in
* @param numrows: The number of rows you want to search through in column_of_interest
*
* @returns: The maximum value in a specific column of a given array
*/
double column_max(double** data_array, int column_of_interest, int numrows) {
    double max = 0; // max must start at a number lower than the expected maximum
    for (int i = 0; i < numrows; i++) {
        if (max <= data_array[i][column_of_interest]) { // Compares each value to current max, replacing max if it's higher
            max = data_array[i][column_of_interest];
        }
    }
    return max;
}

/*
* This function calculates the minimum value in a desired column
*
* @param data_array: A 2D array with rows and columns to examine
* @param column_of_interest: The specific column you want to find the maximum value in
* @param numrows: The number of rows you want to search through in column_of_interest
*
* @returns: The minimum value in a specific column of a given array
*/
double column_min(double** data_array, int column_of_interest, int numrows) {
    double min = 1000; // min must start at a number greater than the expected minimum
    for (int i = 0; i < numrows; i++) {
        if (min >= data_array[i][column_of_interest]) { // Compares each value to current min, replacing min if it's lower
            min = data_array[i][column_of_interest];
        }
    }
    return min;
}

int main (void) {
    
    FILE* ecg_File;
    fopen_s(&ecg_File, "ECG.txt", "r");
    // The number of rows/cols in the ECG data.
    int num_ecg_rows = num_rows_in_file(ecg_File);
    int num_ecg_cols = num_cols_in_file(ecg_File);
    // Load our ECG dataset in to what we'll treat as 2d arrays- So we can index it as ecg_data[rowind][colind]
    double** ecg_data = load_data(ecg_File, num_ecg_rows, num_ecg_cols);
    fclose(ecg_File);
    
    FILE* ergo_File;
    fopen_s(&ergo_File, "ERGO.txt", "r");
    // The number of rows/cols in the ERGO data.
    int num_ergo_rows = num_rows_in_file(ergo_File);
    int num_ergo_cols = num_cols_in_file(ergo_File); 
    // Load our ERGO dataset in to what we'll treat as 2d arrays- So we can index it as ergo_data[rowind][colind]
    double** ergo_data = load_data(ergo_File, num_ergo_rows, num_ergo_cols);
    fclose(ergo_File);

    // Make min/max calls for each non-time column in the array generated by ecg.txt       
    double min_ecg_1 = column_min(ecg_data, 1, num_ecg_rows);
    double max_ecg_1 = column_max(ecg_data, 1, num_ecg_rows);
    double min_ecg_2 = column_min(ecg_data, 2, num_ecg_rows);
    double max_ecg_2 = column_max(ecg_data, 2, num_ecg_rows);

    // Make min/max calls for each non-time column in the array generated by ergo.txt
    double min_ergo_1 = column_min(ergo_data, 1, num_ergo_rows);
    double max_ergo_1 = column_max(ergo_data, 1, num_ergo_rows);
    double min_ergo_2 = column_min(ergo_data, 3, num_ergo_rows);
    double max_ergo_2 = column_max(ergo_data, 3, num_ergo_rows);

    // Print out the results
    printf("The minimum from the healthy ECG is: %f\n", min_ecg_1);
    printf("The maximum from the healthy ECG is: %f\n\n", max_ecg_1);
    printf("The minimum from the damaged ECG is: %f\n", min_ecg_2);
    printf("The maximum from the damaged ECG is: %f\n\n", max_ecg_2);
    printf("The minimum from the first ERGO test is: %f\n", min_ergo_1);
    printf("The maximum from the first ERGO test is: %f\n\n", max_ergo_1);
    printf("The minimum from the second ERGO test is: %f\n", min_ergo_2);
    printf("The maximum from the second ERGO test is %f\n", max_ergo_2);
     
    return 0;
}


/*
* This function loads data, given a already opened input file and known dimensions,
* and returns a double pointer (2D array) dynamically allocated for this purpose.
*
* @param file: An ALREADY OPEN file pointer
* @param numrows: The number of rows in this text file.
* @param numcols: The number of columnss in this text file.
* 
* @returns: a pointer to a dynamically allocated array filled with data from the input file
*/
double** load_data(FILE* file, int numrows, int numcols) {
       
    if (file != NULL) {
        double** dataset = calloc(numrows, sizeof(double *)); // Allocate each of our row pointers.

        if (dataset == NULL) { return NULL; }
        for (int i = 0; i < numrows; i++) {
            dataset[i] = calloc(numcols, sizeof(double)); // Allocate our columns.
            if (dataset[i] == NULL) { return NULL; }
        }

        for (int i = 0; i < numrows; i++) {                     
            for (int j = 0; j < numcols; j++) {
                fscanf_s(file, "%lf", &dataset[i][j]);
            }
        }
        return dataset;
    }   
    else {
        fprintf_s(stderr, "Unable to find file! Ensure it is in the Debug directory.");
        return NULL;
    }  
}

/* 
* This function returns the number of columns in a file.
* 
* @param file: The text file to examine for number of columns.
* 
* @returns: The number of detected columns in the file.
*/
int num_cols_in_file(FILE* file) {
    int numcols = 0;
    if (file) {
        char buf[100]; // Make a buffer we'll use to grab a whole row.

        if (fgets(buf, 100, file) != NULL) {
            // Tokenize our buffer, looking for how many columns we have (aka how many tokens we can create)
            char* token;
            char* next_token = NULL;
            
            token = strtok_s(buf, " \n\r\t,", &next_token);

            while (token != NULL) {
                token = strtok_s(NULL, " \n\r\t,", &next_token);                
                numcols++;
            }
            rewind(file); // Reset our position to the beginning of the file.

            return numcols;
        }
        else {
            fprintf_s(stderr, "Failed to read first row.");
            return 0;
        }
        rewind(file); // Reset our position to the beginning of the file.
    }
    else {
        fprintf_s(stderr, "File is unopened. Numcols only works on opened files.");
        return 0;
    }
}

/*
* This function returns the number of rows in a file.
*
* @param file: The text file to examine for number of rows.
*
* @returns: The number of detected rows in the file.
*/
int num_rows_in_file(FILE* file) {
    int numrows = 0;
    if (file) {
        char buf[100]; // Make a buffer we'll use to grab a whole row.
        
        while ( fgets(buf, 100, file) != NULL) {
            numrows++;

        } 
        rewind(file); // Reset our position to the beginning of the file.

        return numrows;
    }
    else {
        fprintf_s(stderr, "File is unopened. Numrows only works on opened files.");
        return 0;
    }
}
